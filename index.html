<html lang="en">
  <head>
    <style>
      html, body {
        margin: 0;
        height: 100%;
      }

      #world {
        width: 100%;
        height: 100%;
        display: block;
      }

      #container {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      #text-boxes {
        position: absolute;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
        color: white;
      }

      .text-box {
        position: absolute;
        left: 0;
        top: 0;
        color: white;
        background-color: black;

        max-width: 80%;
      }
    
    </style>
  
  </head>
  <body>
    <div id="container">
      <canvas id="world"></canvas>
      <div id="text-boxes"></div>
    </div>
  </body>
  <script id="vertex-shader-2d" type="notjs">
    // so now we're assuming this is pixel position on screen
    attribute vec4 a_position;

    attribute vec2 a_texCoord;

    varying vec2 v_texCoord;

    uniform vec2 u_resolution;
    uniform vec2 u_translation;
    uniform mat4 u_transform;

    // we just need a scale and translate bc we know the sheet is horizontal
    uniform float u_sheetScale;
    uniform float u_sheetTranslate;

    // all shaders have a main function
    void main() {


      gl_Position = u_transform * a_position;

      vec2 texCoordTranslated = a_texCoord + vec2(u_sheetTranslate, 0.0);
      v_texCoord = texCoordTranslated / vec2(u_sheetScale, 1.0);
    }
  </script>
  <script id="fragment-shader-2d" type="notjs">
    // fragment shaders don't have a dfault precision so we need to 
    // pick one. mediump is a good default
    precision mediump float;

    uniform sampler2D u_image;

    varying vec2 v_texCoord;

    void main() {

      gl_FragColor = texture2D(u_image, v_texCoord);
    }
  </script>
  <script id="fragment-shader-pixel-grass" type="notjs">
    // fragment shaders don't have a dfault precision so we need to 
    // pick one. mediump is a good default
    // precision mediump float;

    // uniform sampler2D u_image;

    // varying vec2 v_texCoord;
    float rand1(vec2 st) {
      return fract(sin(dot(st.xy,
                           vec2(12.9898,78.233)))*
          43758.5453123);
    }

    float rand2(vec2 x)
    {
        int n = int(x.x * 40.0 + x.y * 6400.0);
        n = (n << 13) ^ n;
        return 1.0 - float( (n * (n * n * 15731 + 789221) + \
                 1376312589) & 0x7fffffff) / 1073741824.0;
    }

    void main() {
    
    
      gl_FragColor = vec4(rand1(floor(gl_FragCoord.xy)), 
			  1.0, 
			  1.0,
			  1.0);
    }
  </script>

  <script id="vshader-bloom" type="x-shader/x-vertex">
    
    // this shader and the corresponding fragment shader are taken from 
    // https://github.com/mrdoob/three.js/blob/master/examples/webgl_postprocessing_unreal_bloom_selective.html
    //
    // i'm note super sure what they're doing, and i'm not even sure 
    // they're necessary for getting the selective bloom effect, but i 
    // think they are?

    varying vec2 vUv;

    void main() {
      vUv = uv;

      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

    }
  </script>
  <script id="fshader-bloom" type="x-shader/x-fragment">

    uniform sampler2D baseTexture;
    uniform sampler2D bloomTexture;

    varying vec2 vUv;

    void main() {

      gl_FragColor = (texture2D(baseTexture, vUv) + vec4(1.0) * texture2D(bloomTexture, vUv) );
      // gl_FragColor = vec4(0, 1, 0, 1);
    }
  </script>
  <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
  <script src="./index.js"></script>
</html>
